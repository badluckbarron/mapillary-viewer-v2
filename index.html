<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Mapillary tiles → live pins + viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- MapillaryJS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.css" />
  <script src="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.min.js"></script>

  <!-- MapLibre GL -->
  <link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #wrap { position: relative; height: 100vh; width: 100%; }
    #viewer, #map { position: absolute; top: 0; height: 100%; }
    #viewer { left: 0; width: 61.8%; }
    #map    { right: 0; width: calc(38.2% - 2px); }
    #msg {
      position: absolute; left: 8px; top: 8px; z-index: 1000;
      background: rgba(0,0,0,.72); color:#fff; padding:6px 10px; border-radius:6px;
      font: 13px/1.3 system-ui, sans-serif; white-space: pre-line;
      max-width: min(52vw, 780px);
    }
  </style>
</head>
<body>
  <div id="wrap">
    <div id="viewer"></div>
    <div id="map"></div>
    <div id="msg">Loading…</div>
  </div>

  <script>
    // --- Replace with your values ---
    const TOKEN    = "MLY|24840280672250420|6fc0e204403850a11ccc043866f1b01d";
    const START_ID = "744575191439794";   // initial image for the viewer

    // --- Mapillary viewer (left) ---
    const viewer = new mapillary.Viewer({
      container: "viewer",
      accessToken: TOKEN,
      imageId: START_ID,
      component: { cover:false, direction:true, zoom:true, attribution:true }
    });

    // --- Base map (right) ---
    const OSM_RASTER_STYLE = {
      "version": 8,
      "name": "OSM Raster",
      "glyphs": "https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf",
      "sources": {
        "osm": {
          "type": "raster",
          "tiles": ["https://tile.openstreetmap.org/{z}/{x}/{y}.png"],
          "tileSize": 256, "minzoom": 0, "maxzoom": 19,
          "attribution": "© OpenStreetMap contributors"
        },
        // Mapillary vector tiles (mly1_public)
        "mapillary": {
          "type": "vector",
          "tiles": [
            "https://tiles.mapillary.com/maps/vtp/mly1_public/2/{z}/{x}/{y}?access_token=" + encodeURIComponent(TOKEN)
          ],
          "minzoom": 0,
          "maxzoom": 14
        }
      },
      "layers": [
        { "id": "bg",  "type": "background", "paint": { "background-color": "#e6f2d8" } },
        { "id": "osm", "type": "raster", "source": "osm" }
      ]
    };

    const map = new maplibregl.Map({
      container: "map",
      style: OSM_RASTER_STYLE,
      center: [-91.965153, 30.138307],
      zoom: 15
    });

    const $msg = document.getElementById("msg");
    const status = (t)=>{ $msg.textContent = t || ""; };

    map.on("load", () => {
      // Sequence lines (nice context at mid/high zoom)
      map.addLayer({
        id: "mly-sequences",
        type: "line",
        source: "mapillary",
        "source-layer": "sequence",
        minzoom: 13,
        paint: {
          "line-color": "#1976d2",
          "line-opacity": 0.7,
          "line-width": [
            "interpolate", ["linear"], ["zoom"],
            13, 1.0,
            17, 2.5
          ]
        }
      });

      // Image points (the “pins”) – available from z>=14
      map.addLayer({
        id: "mly-images",
        type: "circle",
        source: "mapillary",
        "source-layer": "image",
        minzoom: 14,
        paint: {
          "circle-color": "#1b5e20",
          "circle-opacity": 0.95,
          "circle-radius": [
            "interpolate", ["linear"], ["zoom"],
            14, 2.5,
            18, 5.0
          ],
          "circle-stroke-width": 2,
          "circle-stroke-color": "#b6ffb6"
        }
      });

      status("Click a green dot to open it in the viewer.");

      map.on("mouseenter", "mly-images", () => map.getCanvas().style.cursor = "pointer");
      map.on("mouseleave", "mly-images", () => map.getCanvas().style.cursor = "");

      // Click-to-open behavior
      map.on("click", "mly-images", async (e) => {
        const f = e.features && e.features[0];
        if (!f) return;

        // Try to get an ID straight off the tile feature (common: 'id' or 'image_id')
        const id = f.properties?.id || f.properties?.image_id;
        if (id) {
          try { await viewer.moveTo(String(id)); } catch {}
          return;
        }

        // Fallback: find the nearest image via Graph API and open it
        const [lng, lat] = f.geometry.coordinates;
        try {
          const u = new URL("https://graph.mapillary.com/images");
          u.searchParams.set("fields", "id");
          u.searchParams.set("closeto", `${lng},${lat}`);
          u.searchParams.set("radius", "25");
          u.searchParams.set("limit", "1");
          u.searchParams.set("access_token", TOKEN);
          const r = await fetch(u);
          if (r.ok) {
            const j = await r.json();
            const got = j?.data?.[0]?.id;
            if (got) await viewer.moveTo(String(got));
          }
        } catch(e) {
          console.warn("Nearest lookup failed:", e);
        }
      });
    });

    // Keep a tiny marker/wedge on the map for the current viewer position (optional)
    function makeArcPath(fovDeg){
      const r=45,cx=50,cy=50,rad=Math.PI/180*fovDeg,a0=-Math.PI/2-rad/2,a1=a0+rad;
      const x0=cx+r*Math.cos(a0),y0=cy+r*Math.sin(a0),x1=cx+r*Math.cos(a1),y1=cy+r*Math.sin(a1);
      return `M ${cx} ${cy} L ${x0} ${y0} A ${r} ${r} 0 0 1 ${x1} ${y1} Z`;
    }
    function makeCamera(bearingDeg,fovDeg){
      const path=document.createElementNS('http://www.w3.org/2000/svg','path');
      path.setAttribute('d',makeArcPath(fovDeg)); path.setAttribute('fill','yellow'); path.setAttribute('fill-opacity','0.5');
      path.setAttribute('stroke','black'); path.setAttribute('stroke-width','1'); path.setAttribute('stroke-linejoin','round');
      const svg=document.createElementNS('http://www.w3.org/2000/svg','svg'); svg.setAttribute('viewBox','0 0 100 100'); svg.appendChild(path);
      svg.style.height='100%'; svg.style.width='100%'; svg.style.transform=`rotateZ(${bearingDeg}deg)`;
      const el=document.createElement('div'); el.style.height='200px'; el.style.width='200px'; el.appendChild(svg); return el;
    }
    const cameraEl = makeCamera(0, 90);
    const cameraMarker = new maplibregl.Marker({ element: cameraEl, rotationAlignment: "map" });
    const posDot = document.createElement('div'); posDot.style.cssText="width:14px;height:14px;border:3px solid #ff2a6d;border-radius:50%;background:#fff9";
    const positionMarker = new maplibregl.Marker({ element: posDot, rotationAlignment: "map" });

    async function syncPosition(){
      try{
        const p = await viewer.getPosition();
        const pov = await viewer.getPointOfView();
        positionMarker.setLngLat([p.lng,p.lat]).addTo(map);
        cameraMarker.setLngLat([p.lng,p.lat]).addTo(map);
        cameraEl.querySelector('svg').style.transform=`rotateZ(${pov.bearing}deg)`;
      }catch{}
    }
    viewer.on('load', syncPosition);
    viewer.on('image', syncPosition);
    viewer.on('position', syncPosition);
    viewer.on('pov', syncPosition);
    viewer.on('fov', async () => {
      const vc = viewer.getContainer();
      const vFov = Math.PI/180 * (await viewer.getFieldOfView());
      const aspect = vc.offsetHeight ? vc.offsetWidth / vc.offsetHeight : 0;
      const hFovDeg = Math.atan(aspect * Math.tan(0.5*vFov)) * 2 * 180/Math.PI;
      cameraEl.querySelector('path').setAttribute('d', makeArcPath(hFovDeg));
    });
    window.addEventListener('resize', ()=>viewer.emit && viewer.emit('fov'));
  </script>
</body>
</html>
